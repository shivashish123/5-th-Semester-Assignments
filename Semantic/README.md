Assignment: Semantic Analysis
Authors:
Ajinkya Bokade CS17BTECH11001
Shivashish Suman CS17BTECH11037

Introduction
In this assignment, Static semantics of COOL language has to be checked from
the AST generated by parser.For correct programs, output is annotated AST
which will be used by code generator. For incorrect programs, error messages
are displayed similar to that of COOL compiler.

Inheritance graph
A new java file named ”Graph.java” is created. It contains class Graph and
class Vertex. Vertex is nothing but the nodes of the inheritance graph containing 
the name of class and adjacency list as the attributes.
In this, isCylic method is used to check if there are any cycles in inheritance
graph. It uses two sets visited and recurStack. visited set contains all the
vertices which would be visited while dfs while recurStack contains the vertices
which would be visited while doing dfs from a vertex and if any vertex which is
present in recurStack is visited again, it means presence of cycle. After all the
neighbouring vertices of a vertex has been visited, the vertex is removed from
recurStack.
It also contains conformance method which takes two class names as parameters and 
check if first conforms to second. Basically, it traverses to the
ancestors of first class until it encounters second class name which means that
first is descendant of second. Hence it conforms to second.
It also contains lca (least common ancestor method) which takes two class
names as parameters and find the lca of the two vertices in inheritance graph.
So here, we are storing the path of each vertex to the root of graph in a list.
Then, we start comparing from the end of the lists of paths of two vertices and
keep traversing until a mismatch is found. So, the vertex previous to mismatch
is the lca of two vertices.

Semantic.java
Here we have created a HashMap named classMap which contains class name
as key and class object as value. Also, two scope tables have been created
namely objectEnv and methodEnv. objectEnv is a scope table of map of
attribute name and its type. methodEnv is a scope table of map of method
name and list of formals of that method.
Main class of COOL Object and other basic classes of COOL like IO, Int, Bool,
String and their methods were added in methodEnv.

Traversals
In first pass of traversal, we checked if Main class exists or not and also ensured
that basic classes such as Object, IO, Int, String, Bool are not redefined and
neither are they being inherited and then adding these classes into classMap
and add the edge between the class and its parent in inheritance graph.
Once, inheritance graph is created, it is checked if the graph contains any cycle.
If yes, error is reported and program terminates.
In second pass of traversal, it is checked if parent of class is defined or not.
Also, two hashMaps are created for storing type of attributes and formals of
methods of the class. In this traversal, for each class, each feature of class is
traversed. If the features is attribute, then its checked if the attribute is already
defined in the class or in its ancestor. If so, error is reported. Else, its name
and type is added to attribute map. If feature is method, then its checked if its
already defined in that class. Then its also checked that if the method exists in
one of the ancestors of that class, then return type of method and the number
of formals and type of each formal should be same (method overriding). Also
its checked that the formal name isnt repeated. For this, set of formal names is
created so that searching is faster.
Checking of main method with no formals in Main class is also done here.
Then, the methodMap is added to methodEnv and attributeMap is added
to objectEnv.
In third pass of traversal, each node is visited using visitor pattern mechanism.

Visitor Pattern
Using visitor pattern mechanism, each node of AST is being visited recursively
and type and scope is being checked.
Each method and attribute of each class is visited.

Visit Method node
While visiting method node, we create a HashMap of formal name and typeid.
First we insert self and class name as its type into the map. Then we traverse
through the formals and insert the formal name and its type. Then we call
updateObjectEnv which increments scope and adds these new variables in
the scope. Then body of method is visited. Scope is decremented. Then type
checking is done. It is checked if return type of method is defined (valid) or
not. Also it is checked that type of body conforms with declared return type of
method.

Visit attribute node
First we obtain the attributeTypeMap of the current class by objectEnv.
Then it is checked if the type of attribute node is defined (valid) or not. Then we
update scope and visit the expression node of the attribute. Then it is checked
that the type of expression node conforms with declared type of attribute. Then
scope is decremented.

Visit block node
Each expression in the block is visited and the type of block node is assigned
type of last expression

Visit assign node
We check the type of attribute in the whole class hierarchy. Its also checked if
this type is defined or not. Then the expression node is visited and then it is
checked that the type of expression conforms with the declared type of attribute.

Visit expression node
Depending upon the node, its corresponding visitor pattern call is invoked.

Visit dispatch node
First, we visit the caller node. Then we maintain a list of actuals by visiting
each actual. Then we check that the number of actuals (arguments) are same
as the number of parameters in actual method and that type of each actual
conforms with the type of parameter.

Visit static dispatch node
It is similar to dispatch except here, we also check that the type of caller 
conforms with actual type of static dispatch node.

Visit cond node
First predicate node is visited. Then it is checked if the type of predicate node
is Bool or not. Then if body of cond is visited and then else body. Then lca of
type of if body and type of else body is assigned to cond node.

Visit loop node
First predicate node is visited. Then it is checked if the type of predicate node
is Bool or not. Then body node is visited.

Visit typecase node
First, We visit the predicate node. We check that type of predicate node is Bool.
Then for each branch, we enter the new scope by updating object environment
with new set of variables and after leaving the branch we exit scope. We check
if the declared type of branch is unique by maintaining a set of types of branch
types. Then we visit the expression node and add its type in a list casetypes.
After visiting all branches, we check if the case contains at least one branch or
not. Also, we find the least common ancestor of types of each of the branches
and assign this type to node type.

Visit let node
Here we check that the type of the value node of let conforms with the declared
type. Then, we add this to new scope and assigns the type of let node as type
of its body.

Visit plus node
First we visit the left expression and check if it is equal to Int type and similarly
visit right expression and check if its equal to Int type.

Visit sub node
First we visit the left expression and check if it is equal to Int type and similarly
visit right expression and check if its equal to Int type.

Visit mul node
First we visit the left expression and check if it is equal to Int type and similarly
visit right expression and check if its equal to Int type.

Visit divide node
First we visit the left expression and check if it is equal to Int type and similarly
visit right expression and check if its equal to Int type.

Visit neg node
Here, we check the type of expression node is Int.

Visit lt node
Here, we check that the type of left and right expression is Int and assigns the
type of lt node as Bool.

Visit eq node
Here we visit the left and right expression and check that the types of both
expressions must be Int or String or Bool and that both types must be same so
that they can be compared.

Visit leq node
Here, we visit both expression nodes and check if types of both is Int.

Visit comp node
Here, we visit the expression node and check if its type is Bool.

Visit int const node
We assign type of node as Int.

Visit bool const node
We assign type of node as Bool.

Visit string const node
We assign type of node as String.

Visit new node
We assign type of node same as its typeid.

Visit isvoid node
We visit the expression of node ans assign type of node as Bool.

Visit no expr node
We assign the type of node as no type.

Visit object node
First, we check if object is present in scope table or not and then we check if
the type of node is defined in the class or its ancestor.

Test Cases

Good Test Cases
1) Type annotations for assignments 

2) Testing inheritance of classes

3) Declaration and definition of attributes

4) Method Dispatch

5) Method redefinitions ( Same function in inherited classes )

6) Arithmetic operations (binary and unary) and Comparison operations

7) Rules for case 

8) Loop statement

9) Rules for conditionals

10) Rules for let expression 

Bad Test Cases
1) Program to demonstrate the working of cycle checker in the inheritance graph
   It is evident that there is a cycle in this inheritance graph (E-->A-->B-->C-->D-->E)

2) No Main class 

3) main() method is not present 

4) main() method with arguments

5) Class B inherits class C which does not exist 

6) Creating objects of non-existent class 

7) Repeat attribute in inherited class 

8) Initialize attribute with non-conforming type 

9) Function redefinition with different signature or return type 

10) Names of formal parameters of methods repeat

11) Type of method body does not conform to declared return type 

12) Incorrect static types of arithmetic operations 

13) Use of identifier that does not exist 

14) Predicate of a conditional or a loop not Bool 

15) Redefine attributes or methods in the same scope 
